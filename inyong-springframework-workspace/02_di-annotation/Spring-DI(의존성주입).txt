## 스프링 특징 - DI (Dependency Injection) ##
1. IoC와 연관된 기술로 개발자가 직접 객체를 생성해서 만들어 쓰는게 아니라
   IoC 컨테이너가 관리하고 있는 Bean 객체를 자동으로 주입(대입)해주는 개념
2. 즉, 스프링이 알아서 클래스와 클래스간의 연관관계를 파악해서 그에 맞는 객체를 자동 주입시켜줌
3. 따라서 객체 간의 결합도를 낮출 수 있으며 이로 인해 유지보수성과 유연성이 향상됨


## DI 어노테이션 종류 ##
1. @Inject      : 등록된 Bean들 중 타입(class)이 일치하는 Bean 객체를 주입해주는 어노테이션
2. @Resource    : 등록된 Bean들 중 이름(id)이 일치하는 Bean 객체를 주입해주는 어노테이션
3. @Autowired   : 등록된 Bean들 중 타입(class)이 일치하는 Bean 객체를 주입해주는 어노테이션 (주로 사용)

> 추가 설명
  @Inject나 @Resource는 Spring의 고유 기능이 아니라 Jakarta에서 제공하는 표준 어노테이션이므로
  Spring Framework 없이도 사용 가능함. 단, 어노테이션만 쓴다고 동작하는건 아니고 의존성 주입 처리를 해주는
  구현체(컨테이너)가 필요함. ex) CDI, Guice
  @Autowired는 Spring Framework의 고유 기능으로 Spring 에서만 동작하는 어노테이션


* @Autowired 사용법
1) 필드로 생성된 Bean 객체 주입 받기
    → 필드마다 매번 @Autowired 작성
2) 생성자로 Bean 객체 주입 받기
    → 생성자의 매개변수로 주입받고자 하는 Bean 매개변수 작성
    → @Autowired 작성할 필요 없음
3) 메소드를 이용해서 Bean 객체 주입 받기
    → 메소드의 매개변수로 주입받고자 하는 Bean 매개변수 작성
    → 메소드마다 @Autowired를 작성해야됨
    → 일반적으로 setter 메소드 형태로 작성

-----------------------------------------------------------------------------------------------------------

## 결합도 ##
1. 연관관계의 클래스들 간에 각 클래스 수정시 서로에게 영향을 미치는 정도
   * 연관관계 : 클래스가 다른 클래스를 필드로 참조하는 경우
2. 결합도가 높을 수록 좋지 않음 (한 클래스의 변경이 다른 클래스에 영향을 주기 쉬움, 유지보수가 어려움)
3. 객체 생성시 직접 new로 생성할 경우 결합도가 높다는 문제가 발생됨
   ex)
     public class A {
          private B b = new B(); // A 클래스가 B 클래스를 참조하므로 연관관계 형성 (new로 생성하였으므로 결합도 높음)
     }
     public class B {

     }
   → 만일 B 클래스 변경(생성자 및 메소드 등)시 B 클래스를 사용하고 있는 A 클래스도 일부 수정해야되는 상황 발생
4. 스프링의 IoC와 DI의 특징을 활용할 경우 결합도를 낮출 수 있음 → 유연성, 재사용성 향상
   1) 생성해야될 객체를 Bean으로 등록 (xml|java|어노테이션)
   2) 해당 객체를 직접 new로 생성하는게 아니라 DI를 통해 주입받기 (@Autowired)

-----------------------------------------------------------------------------------------------------------

## IoC + DI ##
1. 프레임워크가 개발에 필요한 모든 객체들을 Bean으로 관리하고 프로그램의 전반적인 흐름을 제어함 (IoC)
   1) 개발자들은 프레임워크에 맞춰 작업해야됨
   2) 환경설정 등을 스프링이 요구하는대로 맞춰 작성해야됨
   3) 스프링 내부에서 필요한 객체들을 Bean으로 등록해서 써야됨
2. 등록된 Bean 객체를 직접 생성하는게 아니라 스프링에게 요청하여 주입받아 쓰면됨 (DI)
   그럼 스프링이 해당 IoC 컨테이너로 부터 관리되는 Bean들 중 타입 또는 이름으로 찾아 주입해줌
3. 장점
   1) 메모리를 보다 효율적으로 사용할 수 있음
       → 직접 new로 생성할 경우 매번 메모리 영역에 새로이 할당되는데
         자주 사용될 객체 또는 동시에 다수가 사용할 객체라면 메모리상에 한번만 생성해두고 재사용하는게 좋음
       → IoC와 DI를 적용하면 IoC 컨테이너에 해당 객체를 한번 생성해서 관리할 수 있도록 할 수 있고
         필요할때마다 생성되어있는 해당 객체를 자동으로 주입받아 사용할 수 있음 (싱글톤 적용이 쉬움)
   2) 클래스간의 결합도가 높은 문제를 해소할 수 있음
       → 결합도가 높을 경우 한 클래스의 변경이 다른 클래스에 영향을 주기 쉬움
       → IoC와 DI를 적용하면 결합도가 낮아져 각 클래스가 독립적으로 동작되게 할 수 있어 유연한 코딩이 가능하며
         소스코드의 수정을 최소화 할 수 있음



** 파라미터 보존 설정 **
1. IntelliJ에서는 컴파일시 파라미터명이 보존 되지 않는 설정이 기본으로 되어있음
2. 생성자 주입이나 메소드 주입시 파라미터명이 보존 되어야됨
3. IntelliJ 설정 변경
   1) File - Settings - Build, Execution, Deployment - Compiler - Java Compiler
       : Additional ~~~ 에 "-parameters" 추가
   2) build.gradle 파일에 tasks.withType(JavaCompile) 내에
       : options.compilerArgs << "-parameters" 추가